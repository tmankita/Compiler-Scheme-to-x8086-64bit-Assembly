
let counter = ref 0 ;;
let next_val= 
  fun ()->
  counter:= !counter +1 ;;

#use "code-gen.ml";;



let file_to_string f =
  let ic = open_in f in
  let s = really_input_string ic (in_channel_length ic) in
  close_in ic;
  s;;

let string_to_asts s = List.map Semantics.run_semantics
                         (Tag_Parser.tag_parse_expressions
                            (Reader.read_sexprs s));;

let primitive_names_to_labels = 
  ["boolean?", "is_boolean"; "float?", "is_float"; "integer?", "is_integer"; "pair?", "is_pair";
   "null?", "is_null"; "char?", "is_char"; "vector?", "is_vector"; "string?", "is_string";
   "procedure?", "is_procedure"; "symbol?", "is_symbol"; "string-length", "string_length";
   "string-ref", "string_ref"; "string-set!", "string_set"; "make-string", "make_string";
   "vector-length", "vector_length"; "vector-ref", "vector_ref"; "vector-set!", "vector_set";
   "make-vector", "make_vector"; "symbol->string", "symbol_to_string"; 
   "char->integer", "char_to_integer"; "integer->char", "integer_to_char"; "eq?", "is_eq";
   "+", "bin_add"; "*", "bin_mul"; "-", "bin_sub"; "/", "bin_div"; "<", "bin_lt"; "=", "bin_equ";
   "cons","cons_pair";"car","car_pair";"cdr","cdr_pair";"set-car!","set_car";"set-cdr!","set_cdr";"apply","apply_as"];;
let const_eq =
  fun (c1,c2)->
  match c1, c2 with
  | Void, Void -> true
  | Sexpr s1,Sexpr s2 -> sexpr_eq s1 s2
  |_->false;;

let check_if_equal =
  fun ((sexpr,(size,ass)),c)->
if (try(const_eq (sexpr, c)) with Invalid_argument _ ->false) then size else -1;; 

let rec find_in_const_table=
  fun (table,c)->
  match table with
  |[]-> -1
  |car::cdr-> let index= (check_if_equal (car,c)) in if (index = -1) then find_in_const_table (cdr,c) else index;;

  let rec labelInFVarTable =
    fun (fvarTable,fvar)->
    match fvarTable with
    | []->""
    | (carName,index)::cdr-> if ((String.compare carName fvar)=0) then  (concate_string_list(["fvar_tbl+";(string_of_int index);"*WORD_SIZE"],"")) else  labelInFVarTable(cdr,fvar);;


let make_prologue consts_tbl fvars_tbl =
  let get_const_address const ="consts+" ^ string_of_int (find_in_const_table (consts_tbl,const))  in
  let get_fvar_address fvar = labelInFVarTable(fvars_tbl,fvar) in
  let make_primitive_closure (prim, label) =
"    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, " ^ label  ^ ")
    mov [" ^ (get_fvar_address prim)  ^ "], rax" in
  let make_constant (c, (a, s)) = s in
  
"
;;; All the macros and the scheme-object printing procedure
;;; are defined in compiler.s
%include \"compiler.s\"

section .bss
malloc_pointer:
    resq 1


section .data

consts:
" ^ (String.concat "\n" (List.map make_constant consts_tbl)) ^ "

;;; These macro definitions are required for the primitive
;;; definitions in the epilogue to work properly
%define SOB_VOID_ADDRESS " ^ get_const_address Void ^ "
%define SOB_NIL_ADDRESS " ^ get_const_address (Sexpr Nil) ^ "
%define SOB_FALSE_ADDRESS " ^ get_const_address (Sexpr (Bool false)) ^ "
%define SOB_TRUE_ADDRESS " ^ get_const_address (Sexpr (Bool true)) ^ "

fvar_tbl:
" ^ (String.concat "\n" (List.map (fun _ -> "dq T_UNDEFINED") fvars_tbl)) ^ "

global main

section .text
main:
    push rbp
    mov rbp, rsp

    ;; set up the heap
    mov rdi, GB(4)
    call malloc
    mov [malloc_pointer], rax

    ;; Set up the dummy activation frame
    ;; The dummy return address is T_UNDEFINED
    ;; (which a is a macro for 0) so that returning
    ;; from the top level (which SHOULD NOT HAPPEN
    ;; AND IS A BUG) will cause a segfault.
    push 0
    push qword SOB_NIL_ADDRESS
    push qword T_UNDEFINED
    push rsp

    jmp code_fragment
 

code_fragment:

    ;; Set up the primitive stdlib fvars:
    ;; Since the primtive procedures are defined in assembly,
    ;; they are not generated by scheme (define ...) expressions.
    ;; This is where we emulate the missing (define ...) expressions
    ;; for all the primitive procedures.
" ^ (String.concat "\n" (List.map make_primitive_closure primitive_names_to_labels)) ^ "

";;
(* mov rax, 1
   mov rdi, 1
   mov rsi, st1
   mov rdx, str_len
   syscall*)
let epilogue = 
  "cons_pair:
    push rbp
    mov rbp, rsp
    mov rdi, PVAR(0)
    mov rsi, PVAR(1)
    MAKE_PAIR (rax, rdi, rsi)
    leave
    ret
    
  car_pair:
    push rbp
    mov rbp, rsp

    mov rsi, PVAR(0)
    mov cl, byte [rsi]
    cmp cl, T_PAIR
    jne .wrong_type
    CAR rax, rsi
    jmp .return

  .wrong_type:
    mov rax, SOB_FALSE_ADDRESS
  .return:
    leave
    ret
  
  cdr_pair:
    push rbp
    mov rbp, rsp

    mov rsi, PVAR(0)
    mov cl, byte [rsi]
    cmp cl, T_PAIR
    jne .wrong_type
    CDR rax, rsi
    jmp .return

  .wrong_type:
    mov rax, SOB_FALSE_ADDRESS
  .return:
    leave
    ret
    
  set_car:
    push rbp
    mov rbp, rsp

    mov rsi, PVAR(0)
    mov cl, byte [rsi]
    cmp cl, T_PAIR
    jne .wrong_type
    lea rsi, [rsi+TYPE_SIZE]
    mov rdi, PVAR(1) 
    push rdi
    pop qword [rsi]
    mov rax, consts+0   
    jmp .return

  .wrong_type:
    mov rax, SOB_FALSE_ADDRESS
  .return:
    leave
    ret

  set_cdr:
    push rbp
    mov rbp, rsp

    mov rsi, PVAR(0)
    mov cl, byte [rsi]
    cmp cl, T_PAIR
    jne .wrong_type
    lea rsi, [rsi+TYPE_SIZE+WORD_SIZE]
    mov rdi, PVAR(1) 
    push rdi
    pop qword [rsi]
    mov rax, consts+0   
    jmp .return

  .wrong_type:
    mov rax, SOB_FALSE_ADDRESS
  .return:
    leave
    ret

    apply_as:

    push rbp
    mov rbp, rsp


    mov rdi,qword [rbp+8*3]
    lea r10, [rbp + 3*8 + rdi*WORD_SIZE]
    mov rsi, qword [r10]      ;;rsi hold the properList
    mov cl, byte [rsi]
    cmp cl, T_PAIR
    jne .noList
 

    ;;;starting frame of reverse function

    push SOB_NIL_ADDRESS
    mov rax, rsi
    push rax
    push 1
    mov rax, qword [fvar_tbl+35*WORD_SIZE]
    CLOSURE_ENV r9, rax
    push r9
    CLOSURE_CODE r9, rax
    call r9
    add rsp, 8*1   ;pop env
    pop rbx        ;pop arg count
    shl rbx, 3     ;rbx = rbx*8
    add rsp, rbx   ;pop args
    add rsp, 8*1   ;pop magic

    ;;;; reverse list in rax;;;
    push SOB_NIL_ADDRESS          ;;pushing magic
    mov rcx, 0x0                  ;;rcx counter of elemnts in proper list
    ;;;; pushing all elements in proper list bn-1-b0  to stack

    .pushingLoop_bs:
    CAR rsi, rax
    push rsi
    inc rcx
    CDR rsi, rax
    cmp rsi, SOB_NIL_ADDRESS             
    je .endLoop_bs
    mov rax, rsi
    jmp .pushingLoop_bs
    .endLoop_bs:
    ;;; now pushing an-1-a0 elemants 
    mov rdi, qword [rbp+8*3]
    lea r10, [rbp + 3*8 + rdi*WORD_SIZE]
    sub r10, WORD_SIZE        ;;;; skip proper list
    sub rdi,0x1     ;no need to copy proper list
    sub rdi,0x1     ;no need to copy f
    cmp rdi, 0x0
    jle .endPushing_as 
    push qword [r10]
    sub rdi,0x1
    cmp rdi, 0x0
    jle .endPushing_as    
    .pushingLoop_as:
    sub r10, WORD_SIZE       
    push qword [r10]
    sub rdi,0x1
    cmp rdi, 0x0
    jg .pushingLoop_as
    .endPushing_as:
    ;;;end pushing an-1-a0
    mov rdi, qword [rbp+8*3]
    sub rdi, 0x2                ;;sub from the count the f and properlist 
    add rdi, rcx
    ;;pushing the new n= as + bs
    push rdi              ;;push new n to stack
    mov r15, rdi                 ;;r15 hold new n
    add r15, 0x4
    ;; pushing env
    mov rax, PVAR(0)
    CLOSURE_ENV r9, rax
    push r9
    CLOSURE_CODE r9, rax   ;; r12 hold the code of f
    ;;pushing ret address
    push qword [rbp+8*1]
    ;; shift frames
    lea r10,[rbp+3*8]
    mov r8, [r10]           ;;n of the prev frame
    mov rbx, qword [rbp]

    SHIFT_FRAME r15, r8
    mov rbp, rbx               ;;pushing old rbp before change
    mov rax, r9
  
    jmp rax    ;jump to code

  .noList:
  ;;check base case that a0=null
    mov rdx,qword [rbp+8*5] ;;rdi hold  the elemant supose to be a0 
    mov rdi,qword [rbp+8*3]
    lea r10, [rbp + 3*8 + rdi*WORD_SIZE]
    mov rsi, qword [r10]      ;;rsi hold the properList
    cmp rsi, rdx
    je .end_no_list_no_params
    ;build new frame for shifting
    push SOB_NIL_ADDRESS          ;;pushing magic
    ;;; now pushing an-1-a0 elemants
    mov rbx,0x0     ;;;;;;;;;;;;;; 
    mov rdi, qword [rbp+8*3]
    lea r10, [rbp + 3*8 + rdi*WORD_SIZE]
    push r9
    mov r9, qword [r10]
    cmp r9, SOB_NIL_ADDRESS
    jne .not_sub_one
    sub r10, WORD_SIZE
    sub rdi,0x1   ;;no need emtpy list
    .not_sub_one:
    pop r9
    sub rdi,0x1     ;no need to copy f
    cmp rdi, 0x0
    jle .endPushing_as_no_list 
    add rbx, 0x1
    push qword [r10]
    sub r10, WORD_SIZE       
    sub rdi,0x1
    cmp rdi, 0x0
    jle .endPushing_as_no_list    
    .pushingLoop_as_no_list:
    add rbx, 0x1
    push qword [r10]
    sub r10, WORD_SIZE        
    sub rdi,0x1
    cmp rdi, 0x0
    jg .pushingLoop_as_no_list
    .endPushing_as_no_list:
    ;;;end pushing an-1-a0
    mov rdi, qword [rbp+8*3]
    sub rdi, 0x1                ;;sub from the count only one because f 
    ;;pushing the new n= as 
    push rbx              ;;push new n to stack
    mov r15, rdi                 ;;r15 hold new n
    add r15, 0x4
    ;; pushing env
    mov rax, PVAR(0)
    CLOSURE_ENV r9, rax
    push r9
    CLOSURE_CODE r9, rax   ;; r12 hold the code of f
    ;;pushing ret address
    push qword [rbp+8*1]
    ;; shift frames
    lea r10,[rbp+3*8]
    mov r8, [r10]           ;;n of the prev frame
    mov rbx, qword [rbp]

    SHIFT_FRAME r15, r8
    mov rbp, rbx               ;;pushing old rbp before change
    mov rax, r9
  
    jmp rax    ;jump to code


  .end_no_list_no_params:
    push SOB_NIL_ADDRESS          ;;pushing magic
    push 0x0                      ;;new n=0
    mov r15, 0x4
    ;; pushing env
    mov rax, PVAR(0)
    CLOSURE_ENV r9, rax
    push r9
    CLOSURE_CODE r9, rax   ;; r12 hold the code of f
    ;;pushing ret address
    push qword [rbp+8*1]
    ;; shift frames
    lea r10,[rbp+3*8]
    mov r8, [r10]           ;;n of the prev frame
    mov rbx, qword [rbp]

    SHIFT_FRAME r15, r8
    mov rbp, rbx               ;;pushing old rbp before change
    mov rax, r9
  
    jmp rax    ;jump to code
";;

let rec print_listOfTuples = 
  fun listT->
  match listT with
  |[]->print_string "]"
  |(name,_)::cdr-> print_string " ";print_string name; print_string ","; print_listOfTuples cdr;;

exception X_missing_input_file;;

try

  let infile = Sys.argv.(1) in
  let code =   (file_to_string "stdlib.scm")^(file_to_string infile)   in
  let asts = string_to_asts code in
  let consts_tbl = Code_Gen.make_consts_tbl asts in
  let fvars_tbl = Code_Gen.make_fvars_tbl asts in (*print_string "\n";print_string "[";print_listOfTuples fvars_tbl;print_string "\n";*)
  let generate =  Code_Gen.generate consts_tbl fvars_tbl in
  let code_fragment = String.concat "\n\n"
                        (List.map
                           (fun ast ->  (next_val(); generate ast) ^ "\n    call write_sob_if_not_void")
                           asts) in
  
  let provided_primitives = file_to_string "prims.s" in
                   
  print_string ((make_prologue consts_tbl fvars_tbl)  ^
                code_fragment ^"\n"^"add rsp, 4*8\n"^"pop rbp\n"^"ret\n"^
                    provided_primitives ^ "\n" ^ epilogue)

with Invalid_argument(x) -> raise X_missing_input_file;;
